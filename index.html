<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mini Block Builder</title>
    
    <!-- FAVICON -->
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCAxMDAgMTAwJz48cmVjdCB3aWR0PScxMDAnIGhlaWdodD0nMTAwJyBmaWxsPScjNENSQUY1MCcgLz48dGV4dCB4PSc1MCcgeT0nNjAnIGZvbnQtc2l6ZT0nNTAnIHRleHQtYW5jaG9yPSdtZWRkbGUnIGZpbGw9JyNGRkZGRkYnPuKaoTwvdGV4dD48L1N2Zz4=">

    <!-- PWA MANIFEST (Must be a link to a file for Android install prompt) -->
    <link rel="manifest" href="manifest.json">

    <!-- Meta Tags for iOS (which doesn't use manifest as much) -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#4CAF50">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            background-color: #87CEEB; /* Fallback color */
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        #instructions {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            text-align: center;
            cursor: default;
        }

        h1 {
            font-size: 60px;
            text-shadow: 4px 4px 0px #000;
            margin-bottom: 10px;
            color: #4CAF50;
        }

        p {
            font-size: 24px;
            text-shadow: 2px 2px 0px #000;
            margin: 10px 0;
        }

        /* Profile Menu Styles */
        #profile-header {
            font-size: 28px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 0 #000;
        }

        #profile-menu {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            margin-bottom: 20px;
            pointer-events: auto;
            flex-wrap: wrap;
            justify-content: center;
        }

        .profile-slot {
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid #4CAF50;
            color: white;
            padding: 20px;
            width: 180px;
            height: 140px;
            border-radius: 15px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: transform 0.1s, background 0.1s;
            position: relative;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .profile-slot:hover { background: rgba(0, 0, 0, 0.8); transform: scale(1.05); }
        .profile-slot:active { transform: scale(0.95); background: #4CAF50; }
        
        .profile-slot.empty { 
            border: 3px dashed #888; 
            opacity: 0.9;
            background: rgba(0,0,0,0.4);
        }
        
        .profile-name { font-size: 22px; font-weight: bold; margin-bottom: 10px; word-break: break-word; text-align: center;}
        
        .profile-delete {
            position: absolute;
            top: -10px;
            right: -10px;
            background: #e74c3c;
            border: 2px solid white;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }
        .profile-delete:hover { background: #c0392b; transform: scale(1.1); }

        /* Start Options (Hidden initially) */
        #start-options {
            display: none;
            gap: 20px;
            margin-top: 20px;
            pointer-events: auto; 
            flex-wrap: wrap;
            justify-content: center;
        }

        .start-btn {
            background: #4CAF50;
            border: 3px solid white;
            color: white;
            padding: 20px 40px;
            font-size: 24px;
            border-radius: 15px;
            cursor: pointer;
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
            transition: transform 0.1s, background 0.1s;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.5);
        }
        .start-btn:active { transform: scale(0.95); box-shadow: 2px 2px 0 rgba(0,0,0,0.5); }
        .start-btn:hover { background: #45a049; }

        /* In-Game Fullscreen Button */
        #game-fullscreen-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.5);
            border: 2px solid white;
            border-radius: 8px;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 400; /* Above everything */
            pointer-events: auto;
        }
        #game-fullscreen-btn:hover { background: rgba(0,0,0,0.8); }

        #message {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: yellow;
            font-size: 30px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: 20;
            text-align: center;
            width: 80%;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path d="M10 0v20M0 10h20" stroke="white" stroke-width="2" style="filter:drop-shadow(1px 1px 1px black);"/></svg>');
            transform: translate(-50%, -50%);
            z-index: 5;
            pointer-events: none;
        }

        #toolbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none; /* Hidden by default on menu */
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 15px;
            gap: 10px;
            z-index: 300; 
            pointer-events: auto;
            transition: top 0.3s, bottom 0.3s, transform 0.3s;
        }

        /* Move toolbar to top on mobile to avoid overlap */
        body.touch-mode #toolbar {
            bottom: auto;
            top: 10px; 
            transform: translateX(-50%) scale(0.85);
        }
        
        .slot {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: transform 0.1s;
            cursor: pointer;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            background-color: rgba(0,0,0,0.2);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 10px;
            text-shadow: 1px 1px 0 #000;
            position: relative; 
        }

        .slot.selected {
            border-color: #FFD700;
            transform: scale(1.2);
            z-index: 2;
            box-shadow: 0 0 15px #FFD700;
        }

        /* Special style for the Undo visual in toolbar */
        .slot.action-slot:active {
            background-color: rgba(255, 99, 71, 0.5);
            transform: scale(0.95);
            border-color: #FF6347;
        }

        /* Hotkey Numbers (1-9, R) */
        .hotkey-num {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
        }
        /* Hide numbers in touch mode */
        body.touch-mode .hotkey-num {
            display: none;
        }

        /* In-Game Top Buttons */
        .top-btn {
            position: absolute;
            top: 10px;
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.5);
            border: 2px solid white;
            border-radius: 8px;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 400;
            pointer-events: auto;
        }
        .top-btn:hover { background: rgba(0,0,0,0.8); }

        #btn-fullscreen { right: 10px; }
        #btn-settings { right: 60px; font-size: 28px; }

        /* Settings Overlay */
        #settings-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 450;
            backdrop-filter: blur(2px);
        }

        /* Settings/Custom Modal */
        #settings-modal, #custom-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 4px solid #4CAF50;
            border-radius: 20px;
            padding: 30px;
            z-index: 500;
            color: white;
            text-align: center;
            min-width: 300px;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        /* Custom Modal Specifics */
        #custom-modal { z-index: 600; }
        #modal-input {
            font-size: 20px;
            padding: 10px;
            margin: 15px 0;
            border-radius: 5px;
            border: 2px solid #555;
            width: 80%;
            font-family: inherit;
        }
        
        #settings-title, #modal-title { font-size: 32px; margin-bottom: 20px; color: #4CAF50; text-shadow: 2px 2px #000; }
        
        .settings-btn, .modal-btn {
            display: block;
            width: 100%;
            margin: 10px 0;
            padding: 12px;
            font-size: 18px;
            border-radius: 8px;
            border: 2px solid #555;
            background: #333;
            color: white;
            cursor: pointer;
            font-family: inherit;
        }
        .settings-btn:hover, .modal-btn:hover { background: #444; border-color: #888; }

        .modal-buttons-row {
            display: flex;
            gap: 10px;
        }
        
        #btn-close-settings { background: #4CAF50; border-color: #45a049; margin-top: 20px; font-weight: bold;}
        #btn-reset-world { background: #e74c3c; border-color: #c0392b; }
        #btn-export { background: #3498db; border-color: #2980b9; }
        #btn-import { background: #9b59b6; border-color: #8e44ad; }
        
        #modal-yes { background: #4CAF50; }
        #modal-no { background: #e74c3c; }

        /* --- Touch Controls --- */
        #mobile-controls {
            display: none;
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: 100;
            pointer-events: none;
        }

        .touch-btn {
            position: absolute;
            background: rgba(255, 255, 255, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            color: white;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            user-select: none;
            z-index: 200; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.1s, background-color 0.2s;
        }
        
        .touch-btn:active {
            transform: scale(0.90);
        }

        #joystick-zone {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 120px;
            height: 120px;
            background: rgba(0,0,0,0.2);
            border-radius: 50%;
            pointer-events: auto;
            z-index: 200;
        }

        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #btn-jump { bottom: 40px; right: 20px; width: 80px; height: 80px; font-size: 16px; background: rgba(0, 200, 0, 0.5); }
        
        /* The Unified Action Button (Right) */
        #btn-action { 
            bottom: 140px; 
            right: 30px; 
            width: 100px; 
            height: 100px; 
            font-size: 40px; 
            background: rgba(0, 0, 200, 0.5); 
            border-width: 4px;
        }

        /* The Unified Action Button (Left) */
        #btn-action-left { 
            bottom: 180px; 
            left: 20px; 
            width: 80px; 
            height: 80px; 
            font-size: 30px; 
            background: rgba(0, 0, 200, 0.5); 
            border-width: 4px;
        }

        #look-zone {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
            z-index: 99;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="blocker">
        <div id="instructions">
            <h1>Mini Block Builder</h1>
            
            <div id="profile-header">Select World:</div>
            <div id="profile-menu">
                <!-- Profile slots injected here by JS -->
            </div>

            <div id="start-options">
                <button id="btn-mouse" class="start-btn">üñ±Ô∏è PC</button>
                <button id="btn-touch" class="start-btn">üì± Mobile</button>
            </div>
            
            <div id="creator-note" style="margin-top:40px; font-size: 18px; color: #88ccff; text-shadow: 1px 1px 0 #000; font-style: italic;">
                Created by Dan Baruch for his kiddos and yours
            </div>
        </div>
    </div>

    <!-- In-Game Top Buttons -->
    <div id="btn-fullscreen" class="top-btn" title="Toggle Fullscreen">‚õ∂</div>
    <div id="btn-settings" class="top-btn" title="Settings">‚öôÔ∏è</div>

    <!-- Settings Overlay (Background) -->
    <div id="settings-overlay"></div>

    <!-- Settings Modal -->
    <div id="settings-modal">
        <div id="settings-title">Settings</div>
        <button id="set-sound" class="settings-btn">üîä Sound: ON</button>
        <button id="set-save" class="settings-btn">üíæ Save Game</button>
        <button id="set-export" class="settings-btn">üì§ Export World</button>
        <button id="set-import" class="settings-btn">üì• Import World</button>
        <button id="set-exit" class="settings-btn" style="background:#f39c12; border-color:#d35400;">üè† Switch World</button>
        <button id="set-reset" class="settings-btn" style="background:#e74c3c;">üóëÔ∏è Reset World</button>
        <button id="set-close" class="settings-btn" style="background:#4CAF50; font-weight:bold;">Resume</button>
        <input type="file" id="file-input" style="display:none;" accept=".json">
    </div>

    <!-- Custom Interaction Modal -->
    <div id="custom-modal">
        <div id="modal-content">
            <h2 id="modal-title">Title</h2>
            <p id="modal-message" style="margin-bottom:15px; font-size: 18px;">Message</p>
            <input type="text" id="modal-input" style="display:none;" maxlength="15" autocomplete="off">
            <div class="modal-buttons-row">
                <button id="modal-yes" class="modal-btn">Yes</button>
                <button id="modal-no" class="modal-btn">No</button>
            </div>
        </div>
    </div>

    <!-- Mobile Controls -->
    <div id="mobile-controls">
        <div id="look-zone"></div>
        <div id="joystick-zone"><div id="joystick-knob"></div></div>
        
        <div id="btn-jump" class="touch-btn">JUMP</div>
        <!-- Single Unified Action Button (Right) -->
        <div id="btn-action" class="touch-btn">üß±</div>
        <!-- Single Unified Action Button (Left) -->
        <div id="btn-action-left" class="touch-btn">üß±</div>
    </div>

    <div id="crosshair"></div>
    <div id="message"></div>
    
    <div id="toolbar">
        <!-- Slots injected by JS -->
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/PointerLockControls.js';

        // --- Service Worker Registration (REQUIRED FOR PWA) ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }

        // --- Game Configuration ---
        const BLOCK_SIZE = 10;
        let inputMode = 'mouse'; 
        
        const PLAYER_HEIGHT = 20;
        const PLAYER_RADIUS = 3;

        // Profile & Save Constants
        const PROFILES_KEY = 'miniBlockBuilder_profiles_v1';
        const SAVE_PREFIX = 'miniBlockBuilder_save_v1_';
        let currentProfileId = null;

        // --- Sound System ---
        let soundEnabled = true;
        let audioCtx = null; 

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            } else if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playSound(type) {
            if (!soundEnabled) return;
            initAudio(); 

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'build') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(1000, now + 0.1);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'break') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
            } else if (type === 'shoot') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(200, now + 0.3);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'jump') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(500, now + 0.1);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'hit') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            }
        }

        // Consolidated Sound Toggle Function
        function toggleSound() {
            soundEnabled = !soundEnabled;
            // Update Settings Button
            const setBtn = document.getElementById('set-sound');
            if (setBtn) {
                setBtn.innerText = soundEnabled ? "üîä Sound: ON" : "üîá Sound: OFF";
            }
            if (soundEnabled) initAudio();
        }

        // --- Custom Modal System (Replaces prompt/confirm) ---
        const customModal = document.getElementById('custom-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalInput = document.getElementById('modal-input');
        const modalYes = document.getElementById('modal-yes');
        const modalNo = document.getElementById('modal-no');
        let modalCallback = null;

        function showPrompt(title, defaultValue, callback) {
            modalTitle.innerText = title;
            modalMessage.style.display = 'none';
            modalInput.style.display = 'block';
            modalInput.value = defaultValue;
            modalYes.innerText = "OK";
            modalNo.innerText = "Cancel";
            
            customModal.style.display = 'flex'; // Use flex to center
            modalInput.focus();
            
            modalCallback = (result) => {
                customModal.style.display = 'none';
                if (result) callback(modalInput.value);
            };
        }

        function showConfirm(title, message, callback) {
            modalTitle.innerText = title;
            modalMessage.style.display = 'block';
            modalMessage.innerText = message;
            modalInput.style.display = 'none';
            modalYes.innerText = "Yes";
            modalNo.innerText = "No";
            
            customModal.style.display = 'flex';
            
            modalCallback = (result) => {
                customModal.style.display = 'none';
                if (result) callback();
            };
        }

        modalYes.onclick = () => { if(modalCallback) modalCallback(true); };
        modalNo.onclick = () => { if(modalCallback) modalCallback(false); };
        // Touch support for modal buttons
        modalYes.addEventListener('touchstart', (e) => { e.preventDefault(); if(modalCallback) modalCallback(true); }, {passive: false});
        modalNo.addEventListener('touchstart', (e) => { e.preventDefault(); if(modalCallback) modalCallback(false); }, {passive: false});


        // --- Settings Menu Logic ---
        const settingsModal = document.getElementById('settings-modal');
        const settingsOverlay = document.getElementById('settings-overlay');
        const btnSettings = document.getElementById('btn-settings');
        const btnCloseSettings = document.getElementById('set-close');
        
        function openSettings() {
            if (settingsModal.style.display === 'block') return; // Already open
            
            // Show UI first to set state, preventing race conditions in unlock listener
            settingsModal.style.display = 'block';
            settingsOverlay.style.display = 'block';
            
            if (controls.isLocked) {
                controls.unlock();
            }
        }

        function closeSettings() {
            settingsModal.style.display = 'none';
            settingsOverlay.style.display = 'none';
            // Only resume/lock if a game is active (profile selected)
            if (currentProfileId && inputMode === 'mouse') {
                controls.lock();
            }
        }

        btnSettings.addEventListener('click', openSettings);
        
        // Touch handler for settings button
        btnSettings.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            openSettings();
        }, {passive: false});

        // Close when clicking overlay or close button
        settingsOverlay.addEventListener('click', closeSettings);
        settingsOverlay.addEventListener('touchstart', (e) => {
            e.preventDefault();
            closeSettings();
        }, {passive: false});
        btnCloseSettings.addEventListener('click', closeSettings);

        // Escape Key logic
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Escape') {
                if (settingsModal.style.display === 'block') {
                    closeSettings();
                }
            }
        });

        // Settings Buttons
        // Use the unified toggleSound function
        document.getElementById('set-sound').addEventListener('click', toggleSound);
        
        document.getElementById('set-reset').addEventListener('click', resetWorld);
        document.getElementById('set-save').addEventListener('click', () => {
            saveWorld();
            showMessage("Game Saved! üíæ", "lime");
            closeSettings();
        });
        
        // Exit to Main Menu Logic
        const handleExit = () => {
            showConfirm("Switch World?", "Return to world selection? Progress is saved.", () => {
                saveWorld(); 
                currentProfileId = null; // Set null BEFORE closing so it doesn't auto-lock mouse
                closeSettings();

                // UI Reset
                document.getElementById('blocker').style.display = 'flex';
                document.getElementById('instructions').style.display = 'flex'; 
                document.getElementById('profile-menu').style.display = 'flex';
                document.getElementById('start-options').style.display = 'none';
                document.getElementById('profile-header').innerText = "Select World:";
                document.getElementById('toolbar').style.display = 'none';
                
                document.getElementById('mobile-controls').style.display = 'none';
                document.body.classList.remove('touch-mode'); 
                
                // Reset Camera Angle for menu background
                camera.rotation.set(0, 0, 0);

                // Reset movement
                moveState.forward = false;
                moveState.backward = false;
                moveState.left = false;
                moveState.right = false;

                clearWorld();
                renderProfileMenu();
            });
        };
        
        const btnSetExit = document.getElementById('set-exit');
        btnSetExit.addEventListener('click', handleExit);
        btnSetExit.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleExit();
        }, {passive: false});

        // Export
        document.getElementById('set-export').addEventListener('click', () => {
            if (!currentProfileId) return;
            const json = localStorage.getItem(SAVE_PREFIX + currentProfileId);
            if (!json) return;
            
            const blob = new Blob([json], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `miniblock_world_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        });

        // Import
        const fileInput = document.getElementById('file-input');
        document.getElementById('set-import').addEventListener('click', () => fileInput.click());
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (ev) => {
                let data;
                try {
                    data = JSON.parse(ev.target.result);
                    
                    // Basic structural validation: check if it's an array and if elements have required properties
                    if (!Array.isArray(data) || !data.every(item => typeof item === 'object' && 'x' in item && 'y' in item && 'z' in item && 't' in item)) {
                        console.error("Import Failed: File structure is incorrect.", data);
                        showMessage("Import Failed: File structure is incorrect.", "red");
                        return;
                    }

                    localStorage.setItem(SAVE_PREFIX + currentProfileId, JSON.stringify(data));
                    showMessage("World Imported! üì¶", "lime");
                    closeSettings();
                    clearWorld();
                    loadWorld();
                    
                } catch(err) {
                    console.error("Import JSON parsing error:", err);
                    showMessage("Import Failed: Invalid JSON format.", "red");
                }
            };
            // Reset input value so 'change' event fires if user selects same file again
            e.target.value = ''; 
            reader.readAsText(file);
        });


        // In-Game Fullscreen Toggle Logic
        const gameFullscreenBtn = document.getElementById('btn-fullscreen');
        const toggleFullscreen = () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        };
        gameFullscreenBtn.addEventListener('click', toggleFullscreen);
        gameFullscreenBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            toggleFullscreen();
        }, {passive: false});


        // --- Undo/Redo System ---
        const undoStack = [];
        const redoStack = [];

        function showMessage(text, color = 'yellow') {
            const el = document.getElementById('message');
            el.innerText = text;
            el.style.color = color;
            el.style.opacity = 1;
            if(el.timeout) clearTimeout(el.timeout);
            el.timeout = setTimeout(() => { el.style.opacity = 0; }, 2000);
        }

        // --- Save System ---
        function saveWorld() {
            if (!currentProfileId) return; // Don't save if no profile selected
            const data = [];
            for (let [key, val] of worldData) {
                const parts = key.split(',');
                data.push({
                    x: parseInt(parts[0]),
                    y: parseInt(parts[1]),
                    z: parseInt(parts[2]),
                    t: val.typeIndex
                });
            }
            try {
                localStorage.setItem(SAVE_PREFIX + currentProfileId, JSON.stringify(data));
            } catch (e) {
                console.warn("Save failed", e);
            }
        }

        function loadWorld() {
            if (!currentProfileId) return false;
            const json = localStorage.getItem(SAVE_PREFIX + currentProfileId);
            if (!json) return false;
            
            try {
                const data = JSON.parse(json);
                if (!Array.isArray(data) || data.length === 0) return false;

                // Load blocks (don't save during load, don't add to undo)
                data.forEach(b => {
                    addBlock(b.x, b.y, b.z, b.t, false, false);
                });
                console.log("World loaded!", data.length + " blocks.");
                return true;
            } catch (e) {
                console.error("Load failed", e);
                return false;
            }
        }

        function resetWorld() {
            showConfirm("Reset World?", "Are you sure you want to delete everything and start over?", () => {
                if (currentProfileId) {
                    localStorage.removeItem(SAVE_PREFIX + currentProfileId);
                    clearWorld();
                    generateDefaultWorld();
                    buildShootingRange();
                    saveWorld();
                    closeSettings();
                }
            });
        }

        // --- Block Types & Assets ---
        function createTexture(color, noiseAmount = 20, type = 'solid') {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, 64, 64);

            if (type !== 'glass') {
                for (let i = 0; i < 200; i++) {
                    ctx.fillStyle = `rgba(0,0,0,${Math.random() * (noiseAmount/100)})`;
                    if (Math.random() > 0.5) ctx.fillStyle = `rgba(255,255,255,${Math.random() * (noiseAmount/100)})`;
                    const x = Math.floor(Math.random() * 64);
                    const y = Math.floor(Math.random() * 64);
                    const w = Math.ceil(Math.random() * 4);
                    const h = Math.ceil(Math.random() * 4);
                    ctx.fillRect(x, y, w, h);
                }
            }
            
            ctx.strokeStyle = "rgba(0,0,0,0.1)";
            ctx.lineWidth = 4;
            ctx.strokeRect(0,0,64,64);

            if (type === 'wood') {
                ctx.fillStyle = "rgba(0,0,0,0.1)";
                for(let i=10; i<64; i+=10) ctx.fillRect(i, 0, 2, 64);
            }
            if (type === 'brick') {
                ctx.fillStyle = "rgba(200,200,200,0.3)";
                for(let y=0; y<64; y+=16) {
                    ctx.fillRect(0, y, 64, 2);
                    for(let x=0; x<64; x+=32) {
                        let off = (y/16)%2 === 0 ? 0 : 16;
                        ctx.fillRect(x+off, y, 2, 16);
                    }
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            return { texture, canvas };
        }

        const blockTypes = [
            { name: 'Grass', color: '#7CFC00', type: 'grass', mat: null },
            { name: 'Dirt', color: '#8B4513', type: 'solid', mat: null },
            { name: 'Stone', color: '#808080', type: 'solid', mat: null },
            { name: 'Wood', color: '#DEB887', type: 'wood', mat: null },
            { name: 'Leaves', color: '#228B22', type: 'solid', mat: null },
            { name: 'Bricks', color: '#CD5C5C', type: 'brick', mat: null },
            // Removed Weapons from here, reordered
            { name: 'Pickaxe', color: '#333', type: 'tool', mat: null, icon: '‚õèÔ∏è' }, // 6
            { name: 'Fireball', color: '#FF4500', type: 'tool', mat: null, icon: 'üî•' }, // 7
            { name: 'Bow', color: '#8B4513', type: 'tool', mat: null, icon: 'üèπ' }, // 8
            // Hidden blocks at end
            { name: 'Target_Yellow', color: '#FFD700', type: 'solid', mat: null, hidden: true }, // 9
            { name: 'Target_Red', color: '#FF0000', type: 'solid', mat: null, hidden: true }, // 10
        ];

        blockTypes.forEach(b => {
            if (b.type !== 'tool') {
                const data = createTexture(b.color, 20, b.type);
                const material = new THREE.MeshLambertMaterial({ 
                    map: data.texture,
                    transparent: b.type === 'glass',
                    opacity: b.type === 'glass' ? 0.6 : 1.0
                });
                b.mat = material;
                b.iconUrl = data.canvas.toDataURL();
            }
        });

        // --- Init Scene ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 200, 500);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
        camera.rotation.order = 'YXZ'; 
        camera.position.y = 30;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xcccccc);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(100, 200, 100);
        scene.add(dirLight);

        // --- World Data ---
        const objects = []; 
        const worldData = new Map();

        function getBlockKey(x, y, z) {
            return `${Math.round(x)},${Math.round(y)},${Math.round(z)}`;
        }
        
        function isSolid(x, y, z) {
            const bx = Math.round(x / BLOCK_SIZE) * BLOCK_SIZE;
            const by = Math.round(y / BLOCK_SIZE) * BLOCK_SIZE;
            const bz = Math.round(z / BLOCK_SIZE) * BLOCK_SIZE;
            return worldData.has(getBlockKey(bx, by, bz));
        }

        function checkCollision(posX, posY, posZ) {
            const r = PLAYER_RADIUS;
            // Precise hitbox height
            const head = posY - 2;
            const feet = posY - PLAYER_HEIGHT + 2; // Keep +2 buffer for step-up/raycast tolerance
            
            // Check specifically at feet and head, plus mid-body
            const points = [feet, (feet + head) / 2, head];

            for (let y of points) {
                 if (isSolid(posX, y, posZ)) return true;
                 if (isSolid(posX + r, y, posZ)) return true;
                 if (isSolid(posX - r, y, posZ)) return true;
                 if (isSolid(posX, y, posZ + r)) return true;
                 if (isSolid(posX, y, posZ - r)) return true;
            }
            return false;
        }

        // --- Block Logic ---
        function addBlock(x, y, z, typeIndex, isUndoable = true, shouldSave = true) {
            x = Math.round(x / BLOCK_SIZE) * BLOCK_SIZE;
            y = Math.round(y / BLOCK_SIZE) * BLOCK_SIZE;
            z = Math.round(z / BLOCK_SIZE) * BLOCK_SIZE;

            const key = getBlockKey(x, y, z);
            if (worldData.has(key)) return;

            // Prevent placing block inside player
            if (isUndoable) {
                // Temporarily mark this spot as occupied to test collision
                worldData.set(key, { typeIndex: -1 }); 
                const playerCollides = checkCollision(camera.position.x, camera.position.y, camera.position.z);
                worldData.delete(key); // Clear the temporary marker

                if (playerCollides) {
                    showMessage("Can't place here!", "red");
                    return;
                }
            }

            let material;
            
            // Handle Bedrock/Floor (typeIndex -1) specifically for loading
            if (typeIndex === -1) {
                material = new THREE.MeshBasicMaterial({ color: 0x333333 }); 
            } else {
                const bType = blockTypes[typeIndex];
                if (!bType || bType.type === 'tool') return;
                material = bType.mat;
            }

            const geometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(x, y, z);
            
            scene.add(cube);
            objects.push(cube);
            worldData.set(key, { mesh: cube, typeIndex: typeIndex });

            if (isUndoable) {
                undoStack.push({ type: 'add', x, y, z, typeIndex });
                if (undoStack.length > 50) undoStack.shift();
                redoStack.length = 0; 
                playSound('build');
            }

            if (shouldSave) saveWorld();
        }

        function removeBlock(mesh, isUndoable = true, shouldSave = true) {
            let foundKey = null;
            let foundData = null;
            for (let [key, val] of worldData) {
                if (val.mesh === mesh) {
                    foundKey = key;
                    foundData = val;
                    break;
                }
            }

            if (foundKey && foundData) {
                // Protect Bedrock from being removed
                if (mesh.position.y <= -BLOCK_SIZE) {
                    showMessage("Can't break bedrock!", "red");
                    return;
                }

                scene.remove(mesh);
                objects.splice(objects.indexOf(mesh), 1);
                worldData.delete(foundKey);

                if (isUndoable) {
                    undoStack.push({ 
                        type: 'remove', 
                        x: mesh.position.x, 
                        y: mesh.position.y, 
                        z: mesh.position.z, 
                        typeIndex: foundData.typeIndex 
                    });
                    if (undoStack.length > 50) undoStack.shift();
                    redoStack.length = 0;
                    playSound('break');
                }

                if (shouldSave) saveWorld();
            }
        }

        // --- Undo / Redo Functions ---
        function performUndo() {
            const action = undoStack.pop();
            if (!action) {
                showMessage("Nothing to undo!");
                return;
            }

            if (action.type === 'add') {
                const key = getBlockKey(action.x, action.y, action.z);
                const data = worldData.get(key);
                if (data) {
                    removeBlock(data.mesh, false, true); // Undo triggers save
                    redoStack.push(action);
                }
            } else if (action.type === 'remove') {
                addBlock(action.x, action.y, action.z, action.typeIndex, false, true); // Undo triggers save
                redoStack.push(action);
            }
            showMessage("Undo!");
        }

        function performRedo() {
            const action = redoStack.pop();
            if (!action) {
                showMessage("Nothing to redo!");
                return;
            }

            if (action.type === 'add') {
                addBlock(action.x, action.y, action.z, action.typeIndex, false, true);
                undoStack.push(action);
            } else if (action.type === 'remove') {
                const key = getBlockKey(action.x, action.y, action.z);
                const data = worldData.get(key);
                if (data) {
                    removeBlock(data.mesh, false, true);
                    undoStack.push(action);
                }
            }
            showMessage("Redo!");
        }

        // --- World Gen Functions ---
        function generateDefaultWorld() {
            for(let x = -15; x <= 15; x++) {
                for(let z = -15; z <= 15; z++) {
                    // addBlock will save each block, which is slow for 900 blocks.
                    // Pass shouldSave=false, then save once.
                    addBlock(x*BLOCK_SIZE, 0, z*BLOCK_SIZE, 0, false, false); // Grass
                    
                    // Create persistent Bedrock using standard addBlock logic
                    addBlock(x*BLOCK_SIZE, -BLOCK_SIZE, z*BLOCK_SIZE, -1, false, false);
                }
            }
        }

        // --- TARGET SYSTEM ---
        const targetCenterPos = new THREE.Vector3(0, 40, -140); 
        const TARGET_Z = -14;

        function buildShootingRange() {
            const startX = -3; 
            const startZ = TARGET_Z; 
            const width = 7;
            const height = 7;
            
            const yellowIdx = 9; 
            const redIdx = 10;    
            const blackIdx = 2; 

            for(let x = 0; x < width; x++) {
                for(let y = 0; y < height; y++) {
                    const blockX = (startX + x) * BLOCK_SIZE;
                    const blockY = (y + 1) * BLOCK_SIZE; 
                    const blockZ = startZ * BLOCK_SIZE;
                    
                    const dx = x - 3;
                    const dy = y - 3;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    let type = blackIdx; 
                    
                    if (dist < 1.0) type = redIdx; 
                    else if (dist < 2.0) type = yellowIdx; 
                    else if (dist < 3.0) type = redIdx; 
                    
                    addBlock(blockX, blockY, blockZ, type, false, false);
                }
            }
            targetCenterPos.set(0, 40, startZ * BLOCK_SIZE);
        }

        // --- Profile System Functions ---
        function getProfiles() {
            try {
                const stored = localStorage.getItem(PROFILES_KEY);
                return stored ? JSON.parse(stored) : [];
            } catch (e) { return []; }
        }

        function saveProfilesMetadata(profiles) {
            localStorage.setItem(PROFILES_KEY, JSON.stringify(profiles));
        }

        function createProfile(slotIndex) {
            showPrompt("New World", "World " + (slotIndex + 1), (name) => {
                if (!name) return;
                const id = Date.now().toString();
                const profiles = getProfiles();
                profiles.push({ slot: slotIndex, id: id, name: name });
                saveProfilesMetadata(profiles);
                
                localStorage.setItem(SAVE_PREFIX + id, JSON.stringify([]));
                renderProfileMenu();
            });
        }

        function deleteProfile(slotIndex) {
            let profiles = getProfiles();
            const profile = profiles.find(p => p.slot === slotIndex);
            if (profile) {
                // Remove save data
                localStorage.removeItem(SAVE_PREFIX + profile.id);
                // Remove from metadata
                profiles = profiles.filter(p => p.slot !== slotIndex);
                saveProfilesMetadata(profiles);
                renderProfileMenu();
            }
        }

        function selectProfile(id) {
            currentProfileId = id;
            
            // Hide Profile UI, Show Control Selection
            document.getElementById('profile-menu').style.display = 'none';
            document.getElementById('profile-header').innerText = "Select Controls:";
            document.getElementById('start-options').style.display = 'flex';
            
            // Initialize the world (Clear objects first in case of re-run)
            clearWorld();
            
            // Try to load world, or generate default if new
            if (!loadWorld()) {
                generateDefaultWorld();
                buildShootingRange();
                saveWorld(); // Save initial state immediately
            } else {
                // If loaded, just ensure target center is set
                targetCenterPos.set(0, 40, TARGET_Z * BLOCK_SIZE);
            }

            // Toolbar logic handled in button clicks now
        }

        function clearWorld() {
            // Remove all existing blocks from scene before loading/generating
            // Iterate backwards to safely remove
            for(let i = objects.length - 1; i >= 0; i--) {
                scene.remove(objects[i]);
            }
            objects.length = 0;
            worldData.clear();
        }

        function renderProfileMenu() {
            const menu = document.getElementById('profile-menu');
            menu.innerHTML = '';
            const profiles = getProfiles();

            for (let i = 0; i < 3; i++) {
                const profile = profiles.find(p => p.slot === i);
                const slotDiv = document.createElement('div');
                slotDiv.className = 'profile-slot';
                
                if (profile) {
                    const nameDiv = document.createElement('div');
                    nameDiv.className = 'profile-name';
                    nameDiv.innerText = profile.name;
                    
                    const playText = document.createElement('div');
                    playText.innerText = "Click to Play ‚ñ∂";
                    playText.style.fontSize = "14px";
                    playText.style.color = "#7CFC00";
                    playText.style.marginTop = "5px";

                    const delBtn = document.createElement('button');
                    delBtn.className = 'profile-delete';
                    delBtn.innerText = 'X';
                    delBtn.title = "Delete World";
                    
                    const delHandler = (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        showConfirm("Delete World?", `Delete "${profile.name}"?`, () => {
                            deleteProfile(i);
                        });
                    };
                    delBtn.addEventListener('click', delHandler);
                    delBtn.addEventListener('touchstart', delHandler, {passive: false});

                    slotDiv.appendChild(delBtn);
                    slotDiv.appendChild(nameDiv);
                    slotDiv.appendChild(playText);
                    
                    // Add listeners to main slot
                    slotDiv.addEventListener('click', () => selectProfile(profile.id));
                    slotDiv.addEventListener('touchstart', (e) => {
                        e.preventDefault(); // Prevent ghost click
                        selectProfile(profile.id);
                    }, {passive: false});

                } else {
                    slotDiv.className += ' empty';
                    slotDiv.innerHTML = '<span style="font-size:30px">‚ûï</span><br>New World';
                    
                    const createHandler = (e) => {
                        e.preventDefault();
                        createProfile(i);
                    };
                    slotDiv.addEventListener('click', () => createProfile(i));
                    slotDiv.addEventListener('touchstart', createHandler, {passive: false});
                }
                menu.appendChild(slotDiv);
            }
        }
        
        // Call this at the very end to ensure everything else is loaded
        renderProfileMenu();


        // --- Ender Dragon ---
        const dragonGroup = new THREE.Group();
        let dragonHealth = 100;
        let dragonDead = false;
        let dragonRespawnTimer = 0;
        scene.add(dragonGroup);
        
        // Dragon Parts
        const dragonMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
        const dragonWingMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
        const dragonEyeMat = new THREE.MeshBasicMaterial({ color: 0xCC00CC }); 

        const dBody = new THREE.Mesh(new THREE.BoxGeometry(10, 8, 20), dragonMat);
        dragonGroup.add(dBody);

        const dNeck = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 10), dragonMat);
        dNeck.position.set(0, 4, 15);
        dNeck.rotation.x = -0.5;
        dragonGroup.add(dNeck);

        const dHead = new THREE.Mesh(new THREE.BoxGeometry(8, 6, 10), dragonMat);
        dHead.position.set(0, 10, 20);
        dragonGroup.add(dHead);

        const dEyeL = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), dragonEyeMat);
        dEyeL.position.set(4.1, 1, 3);
        dHead.add(dEyeL);
        const dEyeR = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), dragonEyeMat);
        dEyeR.position.set(-4.1, 1, 3);
        dHead.add(dEyeR);

        const dTail = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 20), dragonMat);
        dTail.position.set(0, 2, -20);
        dragonGroup.add(dTail);

        const dWingL = new THREE.Group();
        const wingLMesh = new THREE.Mesh(new THREE.BoxGeometry(30, 1, 15), dragonWingMat);
        wingLMesh.position.x = 15;
        dWingL.add(wingLMesh);
        dWingL.position.set(5, 5, 0);
        dragonGroup.add(dWingL);

        const dWingR = new THREE.Group();
        const wingRMesh = new THREE.Mesh(new THREE.BoxGeometry(30, 1, 15), dragonWingMat);
        wingRMesh.position.x = -15;
        dWingR.add(wingRMesh);
        dWingR.position.set(-5, 5, 0);
        dragonGroup.add(dWingR);

        dragonGroup.position.set(0, 80, -60);

        function damageDragon(amount) {
            if (dragonDead) return;
            
            dragonHealth -= amount;
            dBody.material.emissive.setHex(0xFF0000);
            setTimeout(() => { dBody.material.emissive.setHex(0x000000); }, 100);
            
            showMessage(`Dragon HP: ${dragonHealth}`, "orange");
            playSound('hit');

            if (dragonHealth <= 0) {
                dragonDead = true;
                dragonRespawnTimer = 10.0; // Respawn in 10 sec
                showMessage("DRAGON DEFEATED!", "#7CFC00");
            }
        }

        // --- Visual Effects Helper ---
        function flashEntity(group, colorHex, duration = 200) {
            group.traverse((child) => {
                if (child.isMesh) {
                    if (child.userData.flashTimeout) clearTimeout(child.userData.flashTimeout);
                    child.material.emissive.setHex(colorHex);
                    child.userData.flashTimeout = setTimeout(() => {
                        child.material.emissive.setHex(0x000000); // Reset to black (no emission)
                    }, duration);
                }
            });
        }

        // --- Fireballs ---
        const fireballs = [];
        const fireballGeo = new THREE.SphereGeometry(2, 8, 8);
        const fireballMat = new THREE.MeshBasicMaterial({ color: 0xFF4500 });

        function shootFireball() {
            if (dragonDead) {
                // showMessage("The Dragon is defeated (for now...)", "green");
                // Allow shooting anyway for fun
            }

            const fireball = new THREE.Mesh(fireballGeo, fireballMat);
            const startPos = camera.position.clone();
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            startPos.add(dir.multiplyScalar(5)); 
            
            fireball.position.copy(startPos);
            const vel = dir.normalize().multiplyScalar(80);
            
            scene.add(fireball);
            fireballs.push({ mesh: fireball, velocity: vel, life: 3.0 });
            
            swingHand();
            showMessage("FWOOSH!", "orange");
            playSound('shoot');
        }

        // --- Arrows ---
        const arrows = [];
        // Increased size: 0.1 -> 0.3 thickness, 2 -> 5 length
        const arrowGeo = new THREE.CylinderGeometry(0.3, 0.3, 5);
        arrowGeo.rotateX(Math.PI / 2); // Rotate to point along Z
        const arrowMat = new THREE.MeshLambertMaterial({ color: 0xDDDDDD });

        function shootArrow() {
            const arrow = new THREE.Mesh(arrowGeo, arrowMat);
            const startPos = camera.position.clone();
            
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            
            // Adjust start pos
            startPos.add(dir.clone().multiplyScalar(2));
            startPos.y -= 1; // Slightly lower

            arrow.position.copy(startPos);
            arrow.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), dir); // Point arrow forward

            // Velocity: Increased speed (80 -> 150) for more power
            const vel = dir.multiplyScalar(150);
            vel.y += 5; // Slight upward arc

            scene.add(arrow);
            // Increased life to 60.0 seconds
            arrows.push({ mesh: arrow, velocity: vel, stuck: false, life: 60.0 });
            
            swingHand();
            showMessage("Twang!", "white");
            playSound('shoot');
        }

        // --- Player Body (Legs) ---
        const playerBodyGroup = new THREE.Group();
        scene.add(playerBodyGroup);

        const armorMat = new THREE.MeshLambertMaterial({ color: 0x00FFFF }); // Diamond Cyan
        const playerLegGeo = new THREE.BoxGeometry(3, 10, 3);
        
        const myLegL = new THREE.Mesh(playerLegGeo, armorMat);
        myLegL.position.set(-2, -5, 0);
        playerBodyGroup.add(myLegL);

        const myLegR = new THREE.Mesh(playerLegGeo, armorMat);
        myLegR.position.set(2, -5, 0);
        playerBodyGroup.add(myLegR);

        // --- NPC Steve ---
        const steveGroup = new THREE.Group();
        scene.add(steveGroup);

        const skinMat = new THREE.MeshLambertMaterial({ color: 0xffccaa });
        const shirtMat = new THREE.MeshLambertMaterial({ color: 0x00cccc });
        const pantsMat = new THREE.MeshLambertMaterial({ color: 0x0000aa });

        const head = new THREE.Mesh(new THREE.BoxGeometry(8, 8, 8), skinMat);
        head.position.y = 28;
        steveGroup.add(head);

        const body = new THREE.Mesh(new THREE.BoxGeometry(8, 12, 4), shirtMat);
        body.position.y = 18;
        steveGroup.add(body);

        const armL = new THREE.Mesh(new THREE.BoxGeometry(4, 12, 4), shirtMat);
        armL.position.set(-6, 18, 0);
        steveGroup.add(armL);

        const armR = new THREE.Mesh(new THREE.BoxGeometry(4, 12, 4), shirtMat);
        armR.position.set(6, 18, 0);
        steveGroup.add(armR);

        const legL = new THREE.Mesh(new THREE.BoxGeometry(4, 12, 4), pantsMat);
        legL.position.set(-2, 6, 0);
        steveGroup.add(legL);

        const legR = new THREE.Mesh(new THREE.BoxGeometry(4, 12, 4), pantsMat);
        legR.position.set(2, 6, 0);
        steveGroup.add(legR);

        steveGroup.position.set(20, 0, 20);

        let steveTarget = new THREE.Vector3(20, 0, 20);
        let steveMoveTimer = 0;
        let steveHealth = 100;
        let steveDead = false;
        let steveRespawnTimer = 0;

        function damageSteve(amount) {
            if (steveDead) return;
            steveHealth -= amount;
            
            // Visual feedback handled at call site (flashEntity)
            
            if (steveHealth <= 0) {
                steveDead = true;
                steveRespawnTimer = 10.0;
                steveGroup.visible = false;
                showMessage("Steve was defeated!", "red");
                playSound('break'); 
            } else {
                showMessage(`Steve HP: ${steveHealth}`, "white");
            }
        }

        // --- Player Hand & Accessories ---
        const handGroup = new THREE.Group();
        camera.add(handGroup);
        handGroup.position.set(0.5, -0.6, -1);

        const handBlockGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
        const handBlock = new THREE.Mesh(handBlockGeo, blockTypes[3].mat); 
        handGroup.add(handBlock);

        // Pickaxe Visuals
        const pickaxeGroup = new THREE.Group();
        const pickHandle = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.8, 0.05), new THREE.MeshLambertMaterial({color: 0x8B4513}));
        const pickHead = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.08, 0.08), new THREE.MeshLambertMaterial({color: 0x444444}));
        pickHandle.position.y = 0;
        pickHead.position.y = 0.35;
        pickaxeGroup.add(pickHandle);
        pickaxeGroup.add(pickHead);
        
        pickaxeGroup.rotation.z = Math.PI / 8;
        pickaxeGroup.rotation.y = -Math.PI / 4;
        handGroup.add(pickaxeGroup);
        pickaxeGroup.visible = false;

        const fireballItem = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), new THREE.MeshBasicMaterial({color: 0xFF4500}));
        handGroup.add(fireballItem);
        fireballItem.visible = false;

        // Bow Model
        const bowGroup = new THREE.Group();
        const bowCurve = new THREE.Mesh(new THREE.TorusGeometry(0.4, 0.05, 8, 10, Math.PI), new THREE.MeshLambertMaterial({color: 0x8B4513}));
        bowCurve.rotation.z = -Math.PI / 2; // Orient upright
        bowGroup.add(bowCurve);
        // String
        const bowString = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.8), new THREE.MeshBasicMaterial({color: 0xFFFFFF}));
        bowString.position.x = -0.15; 
        bowGroup.add(bowString);
        
        bowGroup.rotation.y = -Math.PI / 2; // Point forward
        handGroup.add(bowGroup);
        bowGroup.visible = false;

        // --- Controls & UI ---
        const controls = new PointerLockControls(camera, document.body);
        
        // Patch controls.lock to handle Promise rejections from requestPointerLock
        controls.lock = function() {
            if (!document.body.isConnected) return;

            try {
                const promise = document.body.requestPointerLock();
                
                if (promise && typeof promise.catch === 'function') {
                    promise.catch(err => {
                        console.warn("PointerLock rejected:", err);
                    });
                }
            } catch (e) {
                console.warn("PointerLock error:", e);
            }
        };

        const instructions = document.getElementById('instructions');
        const blocker = document.getElementById('blocker');
        const btnMouse = document.getElementById('btn-mouse');
        const btnTouch = document.getElementById('btn-touch');

        // Mode Selection Logic
        btnMouse.addEventListener('click', () => {
            initAudio(); // Initialize audio context on first click
            inputMode = 'mouse';
            document.body.classList.remove('touch-mode');
            
            // Show Toolbar
            document.getElementById('toolbar').style.display = 'flex';
            
            // Ensure Mobile Controls are Hidden
            document.getElementById('mobile-controls').style.display = 'none';
            
            controls.lock();
        });

        btnTouch.addEventListener('click', () => {
            initAudio(); // Initialize audio context on first click
            inputMode = 'touch';
            document.body.classList.add('touch-mode');
            
            // Hide start screen, show mobile controls
            blocker.style.display = 'none';
            instructions.style.display = 'none';
            document.getElementById('mobile-controls').style.display = 'block';
            
            // Show Toolbar
            document.getElementById('toolbar').style.display = 'flex';
        });

        controls.addEventListener('lock', () => { 
            instructions.style.display = 'none'; 
            blocker.style.display = 'none';
            // Also ensure settings are closed when we successfully lock
            settingsModal.style.display = 'none';
            settingsOverlay.style.display = 'none';
        });
        
        controls.addEventListener('unlock', () => { 
            // Only show blocker if in mouse mode
            if (inputMode === 'mouse') {
                // If the game was running (blocker is hidden) AND settings are not currently open,
                // open settings on unlock (Escape key). This prevents recursive opening loops.
                if (blocker.style.display === 'none' && settingsModal.style.display === 'none') {
                    openSettings();
                }
            }
        });
        window.addEventListener('contextmenu', (e) => e.preventDefault());

        const moveState = { forward: false, backward: false, left: false, right: false, jump: false };
        
        const onKeyDown = (event) => {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveState.forward = true; break;
                case 'ArrowLeft': case 'KeyA': moveState.left = true; break;
                case 'ArrowDown': case 'KeyS': moveState.backward = true; break;
                case 'ArrowRight': case 'KeyD': moveState.right = true; break;
                case 'Space': if (canJump) { velocity.y += 150; canJump = false; playSound('jump'); } break;
                case 'KeyE': performAction('build'); swingHand(); break;
                case 'KeyQ': performAction('break'); swingHand(); break;
                case 'KeyZ': 
                case 'KeyR': // Added KeyR for Undo, matching the UI label
                    performUndo(); 
                    break;
                case 'KeyY': performRedo(); break;
                case 'Digit1': selectSlot(0); break;
                case 'Digit2': selectSlot(1); break;
                case 'Digit3': selectSlot(2); break;
                case 'Digit4': selectSlot(3); break;
                case 'Digit5': selectSlot(4); break;
                case 'Digit6': selectSlot(5); break;
                case 'Digit7': selectSlot(6); break; // Pickaxe
                case 'Digit8': selectSlot(7); break; // Fireball
                case 'Digit9': selectSlot(8); break; // Bow
                case 'KeyF': toggleFullscreen(); break; // Fullscreen toggle
            }
        };

        const onKeyUp = (event) => {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveState.forward = false; break;
                case 'ArrowLeft': case 'KeyA': moveState.left = false; break;
                case 'ArrowDown': case 'KeyS': moveState.backward = false; break;
                case 'ArrowRight': case 'KeyD': moveState.right = false; break;
            }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        // --- Touch Event Handling ---
        
        // Joystick Logic
        const joystickZone = document.getElementById('joystick-zone');
        const joystickKnob = document.getElementById('joystick-knob');
        let joystickCenter = { x: 0, y: 0 };
        let joystickTouchId = null;

        joystickZone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            joystickTouchId = touch.identifier;
            const rect = joystickZone.getBoundingClientRect();
            joystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
            updateJoystick(touch);
        }, {passive: false});

        joystickZone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === joystickTouchId) {
                    updateJoystick(e.changedTouches[i]);
                    break;
                }
            }
        }, {passive: false});

        joystickZone.addEventListener('touchend', (e) => {
            e.preventDefault();
            joystickTouchId = null;
            joystickKnob.style.transform = `translate(-50%, -50%)`;
            moveState.forward = false;
            moveState.backward = false;
            moveState.left = false;
            moveState.right = false;
        }, {passive: false});

        function updateJoystick(touch) {
            const dx = touch.clientX - joystickCenter.x;
            const dy = touch.clientY - joystickCenter.y;
            
            // Visual Update (Clamp to radius)
            const distance = Math.sqrt(dx*dx + dy*dy);
            const radius = 60; // Max radius
            const clampedDist = Math.min(distance, radius);
            const angle = Math.atan2(dy, dx);
            
            const kx = Math.cos(angle) * clampedDist;
            const ky = Math.sin(angle) * clampedDist;
            
            joystickKnob.style.transform = `translate(calc(-50% + ${kx}px), calc(-50% + ${ky}px))`;

            // Logic Update (Thresholds)
            const threshold = 15;
            moveState.right = dx > threshold;
            moveState.left = dx < -threshold;
            moveState.backward = dy > threshold;
            moveState.forward = dy < -threshold;
        }

        // Camera Look Logic (Touch Drag)
        const lookZone = document.getElementById('look-zone');
        let lastLookX = 0;
        let lastLookY = 0;
        let lookTouchId = null;

        lookZone.addEventListener('touchstart', (e) => {
            const touch = e.changedTouches[0];
            lookTouchId = touch.identifier;
            lastLookX = touch.clientX;
            lastLookY = touch.clientY;
        });

        lookZone.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scroll
            let touch = null;
            for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === lookTouchId) {
                    touch = e.changedTouches[i];
                    break;
                }
            }
            if(!touch) return;

            const deltaX = touch.clientX - lastLookX;
            const deltaY = touch.clientY - lastLookY;

            lastLookX = touch.clientX;
            lastLookY = touch.clientY;

            camera.rotation.y -= deltaX * 0.005;
            camera.rotation.x -= deltaY * 0.005;
            camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));

        }, {passive: false});

        lookZone.addEventListener('touchend', (e) => {
            lookTouchId = null;
        });

        // Touch Buttons Helper
        const bindBtn = (id, actionFn) => {
            const btn = document.getElementById(id);
            if (!btn) return;
            
            const handlePress = (e) => {
                if (e.cancelable) e.preventDefault();
                e.stopPropagation(); // Prevent affecting look-zone
                actionFn();
                btn.style.transform = "scale(0.9)";
            };

            const handleRelease = (e) => {
                if (e.cancelable) e.preventDefault();
                e.stopPropagation();
                btn.style.transform = "scale(1)";
            };

            // Touch Listeners
            btn.addEventListener('touchstart', handlePress, {passive: false});
            btn.addEventListener('touchend', handleRelease, {passive: false});

            // Mouse/Trackpad Listeners (for hybrid devices or testing mobile on PC)
            btn.addEventListener('mousedown', handlePress);
            btn.addEventListener('mouseup', handleRelease);
            btn.addEventListener('mouseleave', handleRelease);
        };

        bindBtn('btn-jump', () => { if (canJump) { velocity.y += 150; canJump = false; playSound('jump'); } });
        
        // Single Action Button Logic
        const handleAction = () => {
            const currentTool = blockTypes[selectedBlockIndex];
            
            if (currentTool.type === 'tool') {
                if (currentTool.name === 'Bow') {
                    shootArrow();
                } else if (currentTool.name === 'Fireball') {
                    shootFireball();
                } else {
                    // Pickaxe
                    performAction('break');
                }
            } else {
                // Block -> Build
                performAction('build');
            }
            swingHand();
        };

        bindBtn('btn-action', handleAction);
        bindBtn('btn-action-left', handleAction);
        bindBtn('btn-undo-mobile', () => { performUndo(); });

        // --- End Touch Handling ---

        let handSwingTime = 0;
        function swingHand() {
            handSwingTime = Math.PI;
        }

        // --- Interaction ---
        const raycaster = new THREE.Raycaster();
        const highlightGeo = new THREE.BoxGeometry(BLOCK_SIZE + 0.5, BLOCK_SIZE + 0.5, BLOCK_SIZE + 0.5);
        const highlightMat = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, opacity: 0.5, transparent: true });
        const highlightMesh = new THREE.Mesh(highlightGeo, highlightMat);
        scene.add(highlightMesh);
        highlightMesh.visible = false;

        let selectedBlockIndex = 3;

        function performAction(action) {
            if (!controls.isLocked && inputMode !== 'touch') return;

            const currentTool = blockTypes[selectedBlockIndex];
            
            if (action === 'break') {
                if (currentTool.name === 'Pickaxe' && !steveDead) {
                      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                      const steveHits = raycaster.intersectObjects(steveGroup.children, true);
                      if (steveHits.length > 0 && steveHits[0].distance < 30) {
                        const pushDir = new THREE.Vector3().subVectors(steveGroup.position, camera.position).normalize();
                        steveGroup.position.add(pushDir.multiplyScalar(5));
                        showMessage("Ouch!", "white");
                        flashEntity(steveGroup, 0xFF0000); 
                        damageSteve(10);
                        playSound('hit');
                      }
                }
            }

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(objects);

            if (intersects.length > 0 && intersects[0].distance < 60) {
                const intersect = intersects[0];
                
                if (action === 'break') {
                    removeBlock(intersect.object);
                    if (currentTool.type === 'tool') {
                        showMessage("Crack!", "white");
                    }
                } else if (action === 'build') {
                    if (currentTool.type === 'tool') {
                        return;
                    }
                    const pos = new THREE.Vector3().copy(intersect.object.position);
                    pos.add(intersect.face.normal.multiplyScalar(BLOCK_SIZE));
                    
                    const playerPos = camera.position.clone();
                    playerPos.y -= 15;
                    const dist = pos.distanceTo(playerPos);
                    
                    if (dist > BLOCK_SIZE * 0.8) {
                        addBlock(pos.x, pos.y, pos.z, selectedBlockIndex);
                    }
                }
            }
        }

        // --- Input Handling (Mouse & Trackpad) ---
        let actionProcessed = false;

        function handleGameAction(button) {
            swingHand();
            
            const currentTool = blockTypes[selectedBlockIndex];

            if (button === 0) {
                if (currentTool.type === 'tool') {
                    if (currentTool.name === 'Bow') shootArrow();
                    else if (currentTool.name === 'Fireball') shootFireball();
                    else performAction('break'); 
                } else {
                    performAction('build'); 
                }
            }
            else if (button === 2) {
                performAction('break'); 
            }
        }

        document.addEventListener('mousedown', (event) => {
            if (!controls.isLocked) return;
            
            // Mark that we handled this action via mousedown
            actionProcessed = true;
            handleGameAction(event.button);

            // Clear the flag after a short delay (enough time for the 'click' event to fire and be ignored)
            setTimeout(() => { actionProcessed = false; }, 300);
        });

        // Global click listener to handle Actions AND Resuming the game
        document.addEventListener('click', (event) => {
            // 1. Resume Game Logic:
            // If in PC mouse mode, and the game is effectively "paused" (unlocked but menus closed),
            // a click on the screen should resume the game (lock pointer).
            if (inputMode === 'mouse' && 
                !controls.isLocked && 
                currentProfileId && 
                blocker.style.display === 'none' && 
                settingsModal.style.display === 'none') {
                
                // Avoid locking if clicking UI elements (like toolbar slots)
                if (event.target.tagName === 'BUTTON' || 
                    event.target.classList.contains('slot') || 
                    event.target.closest('#settings-modal') ||
                    event.target.closest('#custom-modal')) {
                    return;
                }

                controls.lock();
                return; // Stop here, don't fire an action on the resume click
            }

            // 2. Trackpad 'Tap' Support:
            // Taps often fire a 'click' event WITHOUT a preceding 'mousedown' in Pointer Lock.
            if (!controls.isLocked) return;
            
            // If actionProcessed is true, mousedown already handled this. Ignore to prevent double action.
            // If actionProcessed is false, this is a pure tap. Trigger the action!
            if (!actionProcessed && event.button === 0) {
                handleGameAction(0);
            }
        });

        // --- Physics ---
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        let canJump = false;

        // --- Toolbar UI ---
        const toolbar = document.getElementById('toolbar');
        const slots = [];
        let visibleCount = 0; 

        blockTypes.forEach((b, index) => {
            if (b.hidden) return; 

            const slot = document.createElement('div');
            slot.className = 'slot';
            
            const numSpan = document.createElement('span');
            numSpan.className = 'hotkey-num';
            numSpan.innerText = (visibleCount + 1).toString();
            slot.appendChild(numSpan);
            visibleCount++;

            if (b.icon) {
                const iconSpan = document.createElement('span');
                iconSpan.innerText = b.icon;
                iconSpan.style.fontSize = "30px";
                slot.appendChild(iconSpan);
            } else {
                slot.style.backgroundImage = `url(${b.iconUrl})`;
            }
            
            slot.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation(); 
                selectSlot(index);
            }, { passive: false });
            
            slot.addEventListener('mousedown', (e) => {
                 e.preventDefault();
                 selectSlot(index);
            });

            toolbar.appendChild(slot);
            slots.push(slot);
        });

        const undoSlot = document.createElement('div');
        undoSlot.className = 'slot action-slot';
        undoSlot.id = 'desktop-undo';
        undoSlot.innerHTML = '<span style="font-size:30px;">‚Ü©Ô∏è</span><span class="hotkey-num">R</span>';
        
        undoSlot.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            performUndo();
        }, { passive: false });

        undoSlot.addEventListener('mousedown', (e) => {
            e.preventDefault();
            performUndo();
        });
        toolbar.appendChild(undoSlot);

        function selectSlot(index) {
            if (index < 0 || index >= blockTypes.length) return;
            
            selectedBlockIndex = index;
            const b = blockTypes[index];

            let visualIndex = 0;
            let foundVisual = false;
            for(let i=0; i<blockTypes.length; i++) {
                if (blockTypes[i].hidden) continue;
                if (i === index) {
                    foundVisual = true;
                    break;
                }
                visualIndex++;
            }

            if (foundVisual && visualIndex < slots.length) {
                slots.forEach(s => s.classList.remove('selected'));
                slots[visualIndex].classList.add('selected');
            }
            
            handBlock.visible = false;
            pickaxeGroup.visible = false;
            fireballItem.visible = false;
            bowGroup.visible = false;
            
            const btnAction = document.getElementById('btn-action');
            const btnActionLeft = document.getElementById('btn-action-left');
            
            let iconChar = 'üß±';
            let bgImage = 'none';
            let bgColor = 'rgba(0, 0, 200, 0.5)';
            let isBlock = false;

            if (b.name === 'Bow') {
                iconChar = 'üèπ';
                bgColor = 'rgba(255, 100, 0, 0.5)';
            } else if (b.name === 'Fireball') {
                iconChar = 'üî•';
                bgColor = 'rgba(255, 100, 0, 0.5)';
            } else if (b.type === 'tool') {
                iconChar = '‚õèÔ∏è';
                bgColor = 'rgba(200, 0, 0, 0.5)';
            } else {
                // It's a block - use its texture
                isBlock = true;
                bgImage = `url(${b.iconUrl})`;
                bgColor = 'rgba(0, 0, 0, 0.3)'; // Slightly transparent dark bg for blocks
            }

            const updateBtn = (btn) => {
                if (!btn) return;
                if (isBlock) {
                    btn.innerText = '';
                    btn.style.backgroundImage = bgImage;
                    btn.style.backgroundSize = '50%'; // Reduced from 70% to 50% for padding
                    btn.style.backgroundRepeat = 'no-repeat';
                    btn.style.backgroundPosition = 'center';
                } else {
                    btn.innerText = iconChar;
                    btn.style.backgroundImage = 'none';
                }
                btn.style.backgroundColor = bgColor;
            };

            updateBtn(btnAction);
            updateBtn(btnActionLeft);

            if (b.type === 'tool') {
                if (b.name === 'Pickaxe') pickaxeGroup.visible = true;
                if (b.name === 'Fireball') fireballItem.visible = true;
                if (b.name === 'Bow') bowGroup.visible = true;
            } else {
                handBlock.visible = true;
                handBlock.material = b.mat;
            }
        }
        selectSlot(3); 

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);

            if (controls.isLocked === true || inputMode === 'touch') {
                const time = performance.now();
                const delta = (time - prevTime) / 1000;
                prevTime = time;

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 50.0 * delta; 

                const angleY = camera.rotation.y;
                const sin = Math.sin(angleY);
                const cos = Math.cos(angleY);

                let dz = 0;
                let dx = 0;

                if(moveState.forward) { dz -= cos; dx -= sin; }
                if(moveState.backward) { dz += cos; dx += sin; }
                
                if(moveState.right) { dz -= sin; dx += cos; }
                if(moveState.left) { dz += sin; dx -= cos; }

                const len = Math.sqrt(dx*dx + dz*dz);
                if (len > 0) {
                    dx /= len;
                    dz /= len;
                }

                const speed = 400.0;
                
                if (moveState.forward || moveState.backward || moveState.left || moveState.right) {
                    velocity.z -= dz * speed * delta;
                    velocity.x -= dx * speed * delta;
                }

                // COLLISION DETECTION UPDATE (X, Z)
                const deltaX = -velocity.x * delta;
                const deltaZ = -velocity.z * delta;

                // Move X first? Or calc intended position?
                // Our velocity is actually *drag*, movement is applied directly to camera pos here.
                // Let's refactor movement application to use checkCollision
                
                // Calculate proposed new positions
                const nextX = camera.position.x + deltaX;
                const nextZ = camera.position.z + deltaZ;

                // Check X Collision
                if (!checkCollision(nextX, camera.position.y, camera.position.z)) {
                    camera.position.x = nextX;
                } else {
                    velocity.x = 0; // Stop movement in X
                }

                // Check Z Collision
                if (!checkCollision(camera.position.x, camera.position.y, nextZ)) {
                    camera.position.z = nextZ;
                } else {
                    velocity.z = 0; // Stop movement in Z
                }

                // Y Movement (Gravity/Jump)
                const deltaY = velocity.y * delta;
                const nextY = camera.position.y + deltaY;

                if (deltaY > 0) { // Jumping
                    if (checkCollision(camera.position.x, nextY, camera.position.z)) {
                        velocity.y = 0; // Hit ceiling
                    } else {
                        camera.position.y = nextY;
                    }
                } else { // Falling
                    // Check if falling into a block prevents tunneling
                    if (checkCollision(camera.position.x, nextY, camera.position.z)) {
                        velocity.y = 0;
                    } else {
                        camera.position.y = nextY;
                    }
                }

                const playerPos = camera.position.clone();
                const rayOrigin = playerPos.clone();
                rayOrigin.y -= 10;
                const downRay = new THREE.Raycaster(rayOrigin, new THREE.Vector3(0, -1, 0), 0, 20);
                const hits = downRay.intersectObjects(objects);

                if (hits.length > 0) {
                    if (hits[0].distance < 10) {
                        velocity.y = Math.max(0, velocity.y);
                        canJump = true;
                        camera.position.y = hits[0].object.position.y + BLOCK_SIZE/2 + 20; 
                    }
                }
                if (camera.position.y < -100) {
                    velocity.y = 0;
                    camera.position.set(0, 50, 0);
                }

                playerBodyGroup.position.copy(camera.position);
                playerBodyGroup.position.y -= 12; 
                playerBodyGroup.rotation.y = camera.rotation.y;

                if (moveState.forward || moveState.backward || moveState.left || moveState.right) {
                    const walkSpeed = time * 0.01;
                    myLegL.rotation.x = Math.sin(walkSpeed) * 0.8;
                    myLegR.rotation.x = -Math.sin(walkSpeed) * 0.8;
                } else {
                    myLegL.rotation.x = 0;
                    myLegR.rotation.x = 0;
                }

                for (let i = fireballs.length - 1; i >= 0; i--) {
                    const fb = fireballs[i];
                    fb.life -= delta;
                    
                    // Calculate movement for this frame
                    const movement = fb.velocity.clone().multiplyScalar(delta);
                    
                    // Check for block collisions (Environment)
                    const rayDir = movement.clone().normalize();
                    const moveDist = movement.length();
                    const fbRay = new THREE.Raycaster(fb.mesh.position, rayDir, 0, moveDist);
                    const blockHits = fbRay.intersectObjects(objects);

                    if (blockHits.length > 0) {
                        // Hit a block - Poof!
                        scene.remove(fb.mesh);
                        fireballs.splice(i, 1);
                        playSound('break'); // Use break sound for impact
                        continue;
                    }

                    // Apply movement if no collision
                    fb.mesh.position.add(movement);
                    
                    if (!dragonDead) {
                        const dist = fb.mesh.position.distanceTo(dragonGroup.position);
                        if (dist < 15) {
                            damageDragon(10);
                            scene.remove(fb.mesh);
                            fireballs.splice(i, 1);
                            continue;
                        }
                    }

                    if (!steveDead) {
                        const distToSteveCenter = fb.mesh.position.distanceTo(steveGroup.position.clone().add(new THREE.Vector3(0,15,0)));
                        if (distToSteveCenter < 15) { 
                            showMessage("HOT HOT!", "orange");
                            flashEntity(steveGroup, 0xFFA500); 
                            steveGroup.position.y += 20; 
                            damageSteve(10);
                            scene.remove(fb.mesh);
                            fireballs.splice(i, 1);
                            continue;
                        }
                    }

                    if (fb.life <= 0) {
                        scene.remove(fb.mesh);
                        fireballs.splice(i, 1);
                    }
                }

                for (let i = arrows.length - 1; i >= 0; i--) {
                    const ar = arrows[i];
                    if (ar.stuck) {
                        ar.life -= delta;
                        if (ar.life <= 0) {
                            scene.remove(ar.mesh);
                            arrows.splice(i, 1);
                        }
                        continue;
                    }

                    ar.velocity.y -= 9.8 * 2 * delta; 
                    const movement = ar.velocity.clone().multiplyScalar(delta);
                    const nextPos = ar.mesh.position.clone().add(movement);

                    if (ar.velocity.length() > 0.1) {
                        ar.mesh.lookAt(ar.mesh.position.clone().add(ar.velocity));
                    }

                    const rayDir = movement.clone().normalize();
                    const dist = movement.length();
                    const arrowRay = new THREE.Raycaster(ar.mesh.position, rayDir, 0, dist);
                    const blockHits = arrowRay.intersectObjects(objects);
                    if (blockHits.length > 0) {
                        ar.stuck = true;
                        ar.mesh.position.copy(blockHits[0].point);
                        playSound('break'); 
                        
                        // --- SCORING LOGIC ---
                        const hitPos = blockHits[0].point;
                        const dx = hitPos.x - targetCenterPos.x;
                        const dy = hitPos.y - targetCenterPos.y;
                        const distFromCenter = Math.sqrt(dx*dx + dy*dy);
                        
                        if (distFromCenter < 8) showMessage("BULLSEYE! 100 POINTS", "#00FF00");
                        else if (distFromCenter < 18) showMessage("Inner Ring! 50 Points", "#FFFF00");
                        else if (distFromCenter < 28) showMessage("Outer Ring! 20 Points", "#FFA500");
                        else showMessage("Hit! 10 Points", "#FFFFFF");

                        continue;
                    }

                    if (!dragonDead) {
                        const distToDragon = ar.mesh.position.distanceTo(dragonGroup.position);
                        if (distToDragon < 15) { 
                            damageDragon(15);
                            scene.remove(ar.mesh);
                            arrows.splice(i, 1);
                            continue;
                        }
                    }

                    if (!steveDead) {
                        const distToSteveCenter = ar.mesh.position.distanceTo(steveGroup.position.clone().add(new THREE.Vector3(0,15,0)));
                        if (distToSteveCenter < 15) { 
                            const push = ar.velocity.clone().normalize().multiplyScalar(10);
                            push.y = 5;
                            steveGroup.position.add(push.multiplyScalar(0.5));
                            showMessage("Ouch!", "white");
                            flashEntity(steveGroup, 0xFF0000); 
                            damageSteve(10);
                            scene.remove(ar.mesh);
                            arrows.splice(i, 1);
                            playSound('hit');
                            continue;
                        }
                    }

                    ar.mesh.position.copy(nextPos);
                    
                    ar.life -= delta;
                    if (ar.life <= 0 || ar.mesh.position.y < -100) {
                        scene.remove(ar.mesh);
                        arrows.splice(i, 1);
                    }
                }

                if (!dragonDead) {
                    const angle = time * 0.0005;
                    dragonGroup.position.x = Math.sin(angle) * 60;
                    dragonGroup.position.z = Math.cos(angle) * 60;
                    dragonGroup.position.y = 80 + Math.sin(time * 0.002) * 10;
                    dragonGroup.rotation.y = angle + Math.PI;
                    const flap = Math.sin(time * 0.01) * 0.5;
                    dWingL.rotation.z = flap;
                    dWingR.rotation.z = -flap;
                } else {
                    if (dragonGroup.position.y > 0) {
                        dragonGroup.position.y -= 30 * delta;
                        dragonGroup.rotation.z += 1 * delta;
                    } else {
                        dragonGroup.visible = false;
                    }

                    dragonRespawnTimer -= delta;
                    if (dragonRespawnTimer <= 0) {
                        dragonDead = false;
                        dragonHealth = 100;
                        dragonGroup.visible = true;
                        dragonGroup.position.set(0, 80, -60);
                        dragonGroup.rotation.z = 0;
                        showMessage("The Dragon Returns!", "red");
                    }
                }

                if (!steveDead) {
                    steveMoveTimer -= delta;
                    if (steveMoveTimer <= 0) {
                        steveMoveTimer = Math.random() * 3 + 1;
                        const rX = (Math.random() - 0.5) * 100;
                        const rZ = (Math.random() - 0.5) * 100;
                        steveTarget.set(rX, 0, rZ);
                    }
                    
                    const toTarget = new THREE.Vector3().subVectors(steveTarget, steveGroup.position);
                    toTarget.y = 0;
                    if (toTarget.length() > 1) {
                        toTarget.normalize();
                        steveGroup.position.add(toTarget.multiplyScalar(20 * delta));
                        steveGroup.lookAt(steveGroup.position.clone().add(toTarget));
                        
                        const walkCycle = Math.sin(time * 0.01) * 0.5;
                        legL.rotation.x = walkCycle;
                        legR.rotation.x = -walkCycle;
                        armL.rotation.x = -walkCycle;
                        armR.rotation.x = walkCycle;
                    } else {
                        legL.rotation.x = 0; legR.rotation.x = 0;
                        armL.rotation.x = 0; armR.rotation.x = 0;
                    }
                    const steveRay = new THREE.Raycaster(steveGroup.position.clone().add(new THREE.Vector3(0,10,0)), new THREE.Vector3(0,-1,0));
                    const steveHits = steveRay.intersectObjects(objects);
                    if (steveHits.length > 0) {
                    steveGroup.position.y = steveHits[0].point.y;
                    } else {
                    if(steveGroup.position.y > 0) steveGroup.position.y -= 100 * delta;
                    }
                } else {
                    // Respawn Logic
                    steveRespawnTimer -= delta;
                    if (steveRespawnTimer <= 0) {
                        steveDead = false;
                        steveHealth = 100;
                        steveGroup.visible = true;
                        // Respawn at random location
                        const rX = (Math.random() - 0.5) * 100;
                        const rZ = (Math.random() - 0.5) * 100;
                        steveGroup.position.set(rX, 50, rZ);
                        showMessage("Steve Respawns!", "lime");
                    }
                }

                raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
                const intersects = raycaster.intersectObjects(objects);
                if (intersects.length > 0 && intersects[0].distance < 60) {
                    highlightMesh.position.copy(intersects[0].object.position);
                    highlightMesh.visible = true;
                } else {
                    highlightMesh.visible = false;
                }

                if (handSwingTime > 0) {
                    handSwingTime -= delta * 15;
                    handGroup.rotation.x = Math.sin(handSwingTime) * 0.5;
                } else {
                    handGroup.rotation.x = 0;
                }

            } else {
                prevTime = performance.now();
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
